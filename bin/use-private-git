#!/usr/bin/env bash
#
# use-private-git: Enhanced private gitconfig management for repositories
#
# This script manages private git configurations for repositories, supporting
# multiple profiles and automatic detection of work vs personal repositories.
#
# Usage: use-private-git [options]

set -euo pipefail

# Default values
FORCE=false
REMOVE=false
PROFILE="default"
STATUS=false
AUTO_DETECT=false

# Function to get current remote origin URL
get_origin_url() {
    git remote get-url origin 2>/dev/null || echo ""
}

# Function to get current branch name
get_current_branch() {
    git branch --show-current 2>/dev/null || echo ""
}

# Function to get all remote branches
get_remote_branches() {
    git branch -r 2>/dev/null | grep -v "HEAD" | sed 's/^[[:space:]]*origin\///' | head -5
}

# Show usage
show_usage() {
    echo "Usage: $0 [options]"
    echo ""
    echo "Manage private git configurations for repositories"
    echo ""
    echo "Options:"
    echo "  --force              Skip confirmation prompts"
    echo "  --remove             Remove private git configuration"
    echo "  --profile PROFILE    Use specific profile (default: 'default')"
    echo "  --status             Show current configuration status"
    echo "  --auto-detect        Auto-detect work vs personal repository"
    echo "  -h, --help           Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                   # Link default private config"
    echo "  $0 --profile work    # Use work profile"
    echo "  $0 --status          # Show current configuration"
    echo "  $0 --remove          # Remove private configuration"
    echo "  $0 --auto-detect     # Auto-detect repository type"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --force|-f)
            FORCE=true
            shift
            ;;
        --remove)
            REMOVE=true
            shift
            ;;
        --profile)
            if [[ -z "${2:-}" ]]; then
                echo "âŒ Error: --profile requires a profile name" >&2
                exit 1
            fi
            PROFILE="$2"
            shift 2
            ;;
        --status)
            STATUS=true
            shift
            ;;
        --auto-detect)
            AUTO_DETECT=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            echo "âŒ Error: Unknown option '$1'" >&2
            show_usage
            exit 1
            ;;
    esac
done

# Check if we're in a git repository
if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "âŒ Error: Not in a git repository" >&2
    exit 1
fi

# Get the git directory (handles both normal repos and worktrees)
GIT_DIR=$(git rev-parse --git-dir)
LOCAL_GITCONFIG="$GIT_DIR/config"

# Capture current repository info immediately (before any config modifications)
CURRENT_ORIGIN_URL=$(get_origin_url)
CURRENT_BRANCH=$(get_current_branch)
CURRENT_REMOTE_BRANCHES=$(get_remote_branches)

# Function to show current status
show_status() {
    echo "ðŸ“„ Git Configuration Status"
    echo "=========================="
    echo "Repository: $(pwd)"
    echo "Git directory: $GIT_DIR"
    echo ""

    if [[ -L "$LOCAL_GITCONFIG" ]]; then
        echo "ðŸ”— Configuration: Symlinked"
        echo "Target: $(readlink "$LOCAL_GITCONFIG")"
    elif [[ -f "$LOCAL_GITCONFIG" ]]; then
        echo "ðŸ“„ Configuration: Local file"
    else
        echo "âš ï¸  Configuration: Not found"
    fi

    echo ""
    echo "Current user configuration:"
    echo "  user.name: $(git config user.name 2>/dev/null || echo '(not set)')"
    echo "  user.email: $(git config user.email 2>/dev/null || echo '(not set)')"

    # Show remote information
    if git remote get-url origin >/dev/null 2>&1; then
        remote_url=$(git remote get-url origin)
        echo "  remote.origin.url: $remote_url"
    fi

    return 0
}

# Auto-detect repository type
auto_detect_profile() {
    local remote_url
    if remote_url=$(git remote get-url origin 2>/dev/null); then
        # Check common work domain patterns
        if [[ "$remote_url" =~ (github\.com[:/][^/]+/[^/]+|gitlab\.com[:/][^/]+/[^/]+) ]]; then
            # Extract organization/user from URL
            if [[ "$remote_url" =~ github\.com[:/]([^/]+)/ ]]; then
                org="${BASH_REMATCH[1]}"
                # Add your work organizations here
                case "$org" in
                    "spotify"|"company"|"work-org")
                        echo "work"
                        return
                        ;;
                esac
            fi
        fi
        # Check for work-specific patterns in URL
        if [[ "$remote_url" =~ (corp|company|work|enterprise) ]]; then
            echo "work"
            return
        fi
    fi

    # Default to personal
    echo "personal"
}

# Handle status command
if $STATUS; then
    show_status
    exit 0
fi

# Auto-detect profile if requested
if $AUTO_DETECT; then
    detected_profile=$(auto_detect_profile)
    echo "ðŸ¤– Auto-detected profile: $detected_profile"
    PROFILE="$detected_profile"
fi

# Find private gitconfig based on profile
PRIVATE_GITCONFIG_BASE="$HOME/repos/dotfiles/git/.gitconfig.private.base"
if [[ "$PROFILE" == "default" ]]; then
    # Default profile uses only the base config
    PRIVATE_GITCONFIG=""
else
    # Non-default profiles can have additional config
    PRIVATE_GITCONFIG="$HOME/repos/dotfiles/git/.gitconfig.private.$PROFILE"
fi

# Handle remove command
if $REMOVE; then
    if [[ -L "$LOCAL_GITCONFIG" ]]; then
        rm "$LOCAL_GITCONFIG"
        echo "âœ… Private gitconfig symlink removed"

        # Restore backup if it exists
        if [[ -f "${LOCAL_GITCONFIG}.backup" ]]; then
            mv "${LOCAL_GITCONFIG}.backup" "$LOCAL_GITCONFIG"
            echo "ðŸ”„ Restored backup configuration"
        fi
    else
        echo "âš ï¸  No private gitconfig symlink to remove"
    fi
    show_status
    exit 0
fi

# Check if base config exists
if [[ ! -f "$PRIVATE_GITCONFIG_BASE" ]]; then
    echo "âŒ Error: Base private gitconfig not found at $PRIVATE_GITCONFIG_BASE" >&2
    exit 1
fi

# Validate base config syntax
if ! git config -f "$PRIVATE_GITCONFIG_BASE" --list >/dev/null 2>&1; then
    echo "âŒ Error: Invalid git configuration syntax in $PRIVATE_GITCONFIG_BASE" >&2
    exit 1
fi

# Check if profile-specific config exists (optional for non-default profiles)
if [[ "$PROFILE" != "default" && -n "$PRIVATE_GITCONFIG" && ! -f "$PRIVATE_GITCONFIG" ]]; then
    echo "âš ï¸  Warning: Profile-specific gitconfig not found at $PRIVATE_GITCONFIG" >&2
    echo "Using base configuration only." >&2
    echo "Available profiles:" >&2
    find "$HOME/repos/dotfiles/git" -name ".gitconfig.private*" -maxdepth 1 2>/dev/null | sed 's/.*\.gitconfig\.private/  /' | sed 's/^  \.base$/  base (required)/' | sed 's/^  \.old$/  old (backup)/' || echo "  No private configs found" >&2
    # Don't exit - continue with base config only
fi

# Validate profile-specific config syntax if it exists
if [[ -n "$PRIVATE_GITCONFIG" && -f "$PRIVATE_GITCONFIG" ]]; then
    if ! git config -f "$PRIVATE_GITCONFIG" --list >/dev/null 2>&1; then
        echo "âŒ Error: Invalid git configuration syntax in $PRIVATE_GITCONFIG" >&2
        exit 1
    fi
fi

# Check if local config already exists and is not a symlink
if [[ -f "$LOCAL_GITCONFIG" && ! -L "$LOCAL_GITCONFIG" ]]; then
    if [[ "$FORCE" == "false" ]]; then
        echo "âš ï¸  Warning: Local git config exists and is not a symlink"
        echo "Current config: $LOCAL_GITCONFIG"
        echo "This will backup the existing config to ${LOCAL_GITCONFIG}.backup"
        read -p "Continue? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "âŒ Aborted"
            exit 1
        fi
    fi
    mv "$LOCAL_GITCONFIG" "${LOCAL_GITCONFIG}.backup"
    echo "ðŸ’¾ Backed up existing config to ${LOCAL_GITCONFIG}.backup"
fi

# Function to detect repository's default branch
detect_default_branch() {
    local default_branch

    # Try to get the default branch from origin
    if default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null); then
        echo "${default_branch#refs/remotes/origin/}"
        return 0
    fi

    # Try to detect from available branches
    local branches
    if branches=$(git branch -r 2>/dev/null | grep -E "(origin/main|origin/master)" | head -1); then
        echo "${branches#*origin/}"
        return 0
    fi

    # Fallback to current branch
    if default_branch=$(git branch --show-current 2>/dev/null); then
        echo "$default_branch"
        return 0
    fi

    # Last resort
    echo "main"
}

create_dynamic_config() {
    local temp_config
    temp_config=$(mktemp)

    # Start with base configuration
    cp "$PRIVATE_GITCONFIG_BASE" "$temp_config"

    # Add repository-specific init.defaultBranch
    local default_branch
    default_branch=$(detect_default_branch)
    {
        echo ""
        echo "[init]"
        echo "	defaultBranch = $default_branch"
    } >> "$temp_config"

    # Add remote origin configuration if it exists
    if [[ -n "$CURRENT_ORIGIN_URL" ]]; then
        {
            echo ""
            echo "[remote \"origin\"]"
            echo "	url = $CURRENT_ORIGIN_URL"
            echo "	fetch = +refs/heads/*:refs/remotes/origin/*"
            echo "	prune = true"
        } >> "$temp_config"
    fi

    # Add branch tracking configuration
    if [[ -n "$CURRENT_BRANCH" && -n "$CURRENT_ORIGIN_URL" ]]; then
        {
            echo ""
            echo "[branch \"$CURRENT_BRANCH\"]"
            echo "	remote = origin"
            echo "	merge = refs/heads/$CURRENT_BRANCH"
        } >> "$temp_config"
    fi

    # Add tracking for other important branches (main/master/develop)
    local important_branches=("main" "master" "develop" "dev")

    for branch in "${important_branches[@]}"; do
        if [[ "$branch" != "$CURRENT_BRANCH" ]] && echo "$CURRENT_REMOTE_BRANCHES" | grep -q "^$branch$"; then
            {
                echo ""
                echo "[branch \"$branch\"]"
                echo "	remote = origin"
                echo "	merge = refs/heads/$branch"
            } >> "$temp_config"
        fi
    done

    # Add profile-specific configuration if it exists
    if [[ -n "$PRIVATE_GITCONFIG" && -f "$PRIVATE_GITCONFIG" ]]; then
        echo "" >> "$temp_config"
        echo "# Profile-specific configuration" >> "$temp_config"
        # Skip [user] section from profile config to avoid duplicates
        git config -f "$PRIVATE_GITCONFIG" --list | grep -v "^user\." >> "$temp_config" || true
    fi

    echo "$temp_config"
}

# Remove existing symlink if it exists
if [[ -L "$LOCAL_GITCONFIG" ]]; then
    rm "$LOCAL_GITCONFIG"
fi

# Create dynamic configuration
TEMP_CONFIG=$(create_dynamic_config)
mv "$TEMP_CONFIG" "$LOCAL_GITCONFIG"

echo "âœ… Private gitconfig created successfully"
echo "Profile: $PROFILE"
echo "Base config: $PRIVATE_GITCONFIG_BASE"
if [[ -n "$PRIVATE_GITCONFIG" && -f "$PRIVATE_GITCONFIG" ]]; then
    echo "Profile config: $PRIVATE_GITCONFIG"
fi
echo "Default branch: $(detect_default_branch)"

# Show what was auto-configured
if [[ -n "$CURRENT_ORIGIN_URL" ]]; then
    echo "Remote origin: $CURRENT_ORIGIN_URL"
fi

if [[ -n "$CURRENT_BRANCH" ]]; then
    echo "Current branch: $CURRENT_BRANCH (tracking configured)"
fi

if [[ -n "$CURRENT_REMOTE_BRANCHES" ]]; then
    echo "Branch tracking configured for: $CURRENT_BRANCH $(echo "$CURRENT_REMOTE_BRANCHES" | grep -v "^$CURRENT_BRANCH$" | head -3 | tr '\n' ' ')"
fi
echo ""

# Show current user configuration
show_status
